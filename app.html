
<!-- Notification dialog -->
<app_dialog>
    <div ref="top_div" class="modal fade">
        <div class="modal-dialog modal-content">

            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal" aria-hidden="true">
                    <i class="glyphicon glyphicon-remove"></i>
                </button>
                <h4 class="modal-title">
                    {opts.title}
                </h4>
            </div>
            
            <div class="modal-body">
                {opts.msg}
            </div>

            <div class="modal-footer">
                <button class="btn btn-default" data-dismiss="modal">
                    {opts.button}
                </button>
            </div>
        </div>
    </div>
    <script>
        var self = this;
        self.app = opts.app;
        self.modal = function(title, msg, button) {
            self.opts.title = title;
            self.opts.msg = msg;
            self.opts.button = button;
            self.update();
            $(self.refs["top_div"]).modal();
        };
        self.modal_message = function(msg) {
            self.modal("おしらせ", msg, "おｋ");
        }
    </script>
</app_dialog>


<!-- The navigation ber at the top of the window -->
<app_navbar>
    <nav class="navbar navbar-default" ref="app_navbar">
        <div class="container-fluid">

            <div class="navbar-header">
                <div class="navbar-brand">
                    {app.navTitle}
                </div>
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#id_app_navbar">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span> 
                </button>
            </div>
            
            <div class="collapse navbar-collapse" id="id_app_navbar">
                <!-- "navbar-right" alignes items to the right side-->
                <ul class="nav navbar-nav navbar-left">
                    <li>
                        <a href="#home" onclick={onOpenFolder}>
                            <span class="glyphicon glyphicon-folder-open"></span> 
                            フォルダを開く
                        </a>
                    </li>
                    <!--
                    <li>
                        <a href="" onclick={closeDropDown}>
                            <span class="glyphicon glyphicon-cog"></span>
                            設定
                        </a>
                    </li>
                    -->
                </ul>
            </div>

        </div>
    </nav>

    <script>
        var self = this;
        self.app = opts.app;

        // Update handler
        self.on('update', function() {
        });

        // Close the dropdown list
        self.closeDropDown = function(e) {
            $("div#id_app_navbar").collapse("hide");
        }

        // "Open folder" is clicked
        self.onOpenFolder = function(e) {
            self.app.openFolder();
            self.closeDropDown();   // Close the list after click
        }

        // 高さを取得
        self.getHeight = function() {
            return self.refs["app_navbar"].offsetHeight;
        }

    </script>
</app_navbar>


<!-- Application -->
<app>

    <!-- Navigation ber -->
    <app_navbar app={app} ref="app_navbar">  <!-- app を渡している -->
    </app_navbar>

    <!-- -->
    <div style="width:100%; height:100%;" ref="canvas_holder">
        <canvas ref="canvas">
        </canvas>
    </div>

    <!-- Notification dialog
        This dialog is not visible in usual.
     -->
    <app_dialog app={app}></app_dialog>


    <script>
        var self = this;

        // アプリケーションのコンテキスト
        var app = {
            mode: "tome",   // 現在のアプリのモード
            navTitle: "",   // ナビゲーションに設定するタイトル

            tree: null,      // 描画対象
            rectTree: null,      // 描画対象

            // ダイアログを表示
            modalDialog: function(msg) {
                self.tags.app_dialog.modal_message(msg);

            },

            // ナビゲーションに設定するタイトルの変更
            setNavTitle: function(title) {
                // navbar の中でこれを見て勝手に反映してくれる
                app.navTitle = title;
            },

            // フォルダのオープン
            openFolder: function(path){
                context = {
                    count: 0
                };

                //var yosegi = require("electron").remote.require("./yosegi");
                var yosegi = require("./yosegi");
                yosegi.getFileList(
                    //"C:\\",
                    //"./", 
                    "C:\\Users\\shioya\\Desktop\\onikiri2\\lib\\boost\\boost_1_53_0",
                    function(context, treeJSON) {
                        self.app.navTitle = context.count;
                        self.app.calcRects(JSON.parse(treeJSON));
                        self.app.draw();
                    }
                );
            },

            // 矩形領域を計算する
            calcRects: function(tree) {

                function updateDirectorySize(tree) {
                    var size = 0;
                    for(var key in tree) {
                        var val = tree[key];
                        if (val.isDirectory && val.children) {
                            val.size = updateDirectorySize(val.children);
                        }
                        size += val.size;
                    }
                    return size;
                }

                // 各ディレクトリのサイズ反映
                updateDirectorySize(tree);

                var keys = Object.keys(tree);
                keys.sort(function(a, b) {
                    if (tree[a].size > tree[b].size) return -1;
                    if (tree[a].size < tree[b].size) return 1;
                    return 0;
                });
                keys = keys.filter(function(key) {
                    // 空ディレクトリははずしておかないと無限ループする
                    return !(tree[key].isDirectory && tree[key].size < 1);
                });

                function CalcRectTree(rectTree, keys) {

                    rectTree.left = [];
                    rectTree.right = [];
                    rectTree.leftNode = {};
                    rectTree.rightNode = {};
                    rectTree.leftSize = 0;
                    rectTree.rightSize = 0;

                    for (var i = 0; i < keys.length; i++) {
                        if (rectTree.leftSize < rectTree.rightSize) {
                            rectTree.left.push(keys[i]);
                            rectTree.leftSize += tree[keys[i]].size;
                        }
                        else{
                            rectTree.right.push(keys[i]);
                            rectTree.rightSize += tree[keys[i]].size;
                        }
                    }
                    if (rectTree.left.length > 1) {
                        CalcRectTree(rectTree.leftNode, rectTree.left);
                    }
                    if (rectTree.right.length > 1) {
                        CalcRectTree(rectTree.rightNode, rectTree.right);
                    }
                }

                var rectRoot = {};
                CalcRectTree(rectRoot, keys);
                app.rectTree = rectRoot;
                app.tree = tree;
            },

            //　描画
            draw: function() {
                if (!app.tree) {
                    return;
                }

                var canvas = self.refs.canvas;
                var width = canvas.width;
                var height = canvas.height;

                function CalcArea(rectTree, areas, left, top, right, bottom, horizontal) {
                    var width = right - left;
                    var height = bottom - top;
                    if (horizontal) {
                        var leftWidth = width * rectTree.leftSize / (rectTree.leftSize + rectTree.rightSize);
                        var rightWidth = width * rectTree.rightSize / (rectTree.leftSize + rectTree.rightSize);

                        if (rectTree.left.length == 1) {
                            areas.push({
                                key: rectTree.left[0],
                                pos: [left, top, left + leftWidth, bottom]
                            });
                        }
                        else{
                            CalcArea(
                                rectTree.leftNode, areas, left, top, left + leftWidth, bottom, leftWidth > height);
                        }

                        if (rectTree.right.length == 1) {
                            areas.push({
                                key: rectTree.right[0],
                                pos: [left + leftWidth, top, right, bottom]
                            });
                        }
                        else{
                            CalcArea(rectTree.rightNode, areas, left + leftWidth, top, right, bottom, rightWidth > height);
                        }
                    }
                    else {
                        var firstHeight = height * rectTree.leftSize / (rectTree.leftSize + rectTree.rightSize);
                        var secondHeight = height * rectTree.rightSize / (rectTree.leftSize + rectTree.rightSize);

                        if (rectTree.left.length == 1) {
                            areas.push({
                                key: rectTree.left[0],
                                pos: [left, top, right, top + firstHeight]
                            });
                        }
                        else{
                            CalcArea(rectTree.leftNode, areas, left, top, right, top + firstHeight, width > firstHeight);
                        }

                        if (rectTree.right.length == 1) {
                            areas.push({
                                key: rectTree.right[0],
                                pos: [left, top + firstHeight, right, bottom]
                            });
                        }
                        else{
                            CalcArea(rectTree.rightNode, areas, top + firstHeight, right, bottom, width > secondHeight);
                        }

                    }
                }
                var areas = [];
                CalcArea(app.rectTree, areas, 0, 0, width, height, width > height);

                var c = self.refs.canvas.getContext('2d');
                for (var i = 0; i < areas.length; i++) {
                    pos = areas[i].pos;
                    c.fillStyle = "rgb(200, 200, 200)";
                    c.fillRect(pos[0], pos[1], pos[2], pos[3]);

                    c.strokeStyle = "rgb(100, 100, 100)";
                    c.strokeRect(pos[0], pos[1], pos[2], pos[3]);

                    c.font= 'bold 40px Century Gothic';
                    c.strokeStyle = '#00A3D9';
                    c.lineWidth = 6; 
                    c.lineJoin = 'round';
                    c.fillStyle = '#fff';
                    c.fillText(areas[i].key, pos[0] + 10, pos[1] + 40 + 5);
                }


            },

            // リサイズハンドラ
            onResize: function() {
                // CSS で指定するとぼける
                // キャンバスのサイズを無理矢理変更する必要がある
                var canvas = self.refs.canvas;
                var canvas_holder = self.refs.canvas_holder;
                canvas.width = canvas_holder.offsetWidth;
                canvas.height = canvas_holder.offsetHeight;
                app.draw();
            },


            // 初期化
            // タグのマウント時に呼ばれるようにする
            init: function(callback) {
                // ウィンドウのリサイズハンドラ
                window.addEventListener("resize", app.onResize, false);

                //
                app.openFolder();
                app.onResize(); // サイズを適用するために1回呼んどく
            },
        };

        // self にいれておく
        self.app = app;


        // エントリポイント
        // マウント時に初期化を行う
        self.on("mount", app.init);

    </script>
</app>



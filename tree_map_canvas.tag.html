
<tree_map_canvas>
    <canvas ref="canvas">
    </canvas>

    <script>

        let self = this;

        // タイル内の文字のフォントサイズ
        let FONT_FIZE = 15;

        // 各タイルの中の子タイルへのマージン
        // rect の各方向に足される
        let TILE_MERGIN = [8, 8 + FONT_FIZE, -8, -8];

        // タイルマップの初期解像度
        // タイルマップ自体が拡大縮小され，それをビューポート経由で覗いてる構造になる
        let BASE_SIZE = [1600, 900];    

        let ZOOM_RATIO = 0.8;   // 一回に拡大縮小する率 (2^ZOOM_RATIO)
        let ZOOM_ANIMATION_SPEED = 0.07;    // ZOOM_RATIO のフレーム当たり加算値
        
        // ツリーマップ
        /*global TreeMap*/ 
        self.treeMap = new TreeMap();

        // ファイルツリー
        self.tree = null;

        // 表示系
        self.zoomLevel = 0;   // 拡大率
        self.viewPoint =  [0, 0],  // タイルマップ上における表示領域の左上の座標

        // ズームのアニメーション
        self.inZoomAnimation = false;
        self.zoomEndLevel = 0;
        self.zoomBasePoint = [0, 0];
        self.zoomAnimationID = 0;
        self.zoomAnimationDirection = false;

        // マウスのドラッグ
        self.inDrag = false;  // マウスでドラッグ中か
        self.prevMousePoint = [0, 0]; // 前回のマウスポインタの位置

        // リモートモジュール
        self.remote = require("electron").remote;

        // 初期化
        // タグのマウント時に呼ばれるようにする
        self.init = function(){
            let canvas = self.refs.canvas;

            canvas.ondblclick = self.onMouseDoubleClick;

            canvas.onmousewheel = self.onMouseWheel;
            canvas.onmousemove = self.onMouseMove;
            canvas.onmousedown = self.onMouseDown;
            canvas.onmouseup = self.onMouseUp;
            canvas.onmouseleave = self.onMouseUp;
        };

        // マウスのイベントハンドラ
        // ダブルクリック
        self.onMouseDoubleClick = function(e){
            if (!self.tree) {
                return;
            }
            let zoomIn = true;
            if (e.shiftKey) {    // シフトキー時は縮小
                zoomIn = false; 
            }
            self.startZoom(zoomIn, e.clientX, e.clientY);
        };

        // マウスホイール操作
        self.onMouseWheel = function(e){
            if (!self.tree) {
                return;
            }
            self.startZoom(e.deltaY < 0, e.offsetX, e.offsetY);
        };

        // マウス移動
        self.onMouseMove = function(e){
            if (!self.tree) {
                return;
            }
            if (self.inDrag){
                self.viewPoint[0] += self.prevMousePoint[0] - e.offsetX;
                self.viewPoint[1] += self.prevMousePoint[1] - e.offsetY;
                self.prevMousePoint = [e.offsetX, e.offsetY];
                self.draw();
            }
            let pointedFileNode = 
                self.treeMap.getFileNodeFromPoint([e.offsetX, e.offsetY]);
            let pointedPath = 
                self.treeMap.getPathFromFileNode(pointedFileNode);
            //console.log(self.pointedPath);
            if (self.onPointedPathChanged) {
                self.onPointedPathChanged(pointedPath, pointedFileNode);
            }
        };

        self.onMouseDown = function(e){
            if (!self.tree) {
                return;
            }
            // 右クリック
            if (e.buttons & 1) {
                self.inDrag = true;
                self.prevMousePoint = [e.offsetX, e.offsetY];
            }
            // 左クリック
            if (e.buttons & 2) {
                self.popupMenu([e.offsetX, e.offsetY]);
            }

            // クリック時に他所にフォーカスが奪われるのを防ぐ
            e.preventDefault();
        };

        self.onMouseUp = function(e){
            if (!self.tree) {
                return;
            }
            if (!(e.buttons & 1)) { // 離したので 0 になる
                self.inDrag = false;
            }
        };

        // ポップアップメニューの表示
        self.popupMenu = function(pos){
            let fileNode = self.treeMap.getFileNodeFromPoint(pos);
            if (fileNode) {
                let label = "\"" + fileNode.key + "\" を開く";
                if (!fileNode.isDirectory) {
                    label = "\"" + fileNode.key + "\" があるフォルダを開く";
                    fileNode = fileNode.parent;
                }
                let path = self.treeMap.getPathFromFileNode(fileNode);
                let menuTemplate = [
                    {
                        label: label,
                        click: function(){
                            self.remote.shell.openItem(path);
                        }
                    },
                ];
                let menu = self.remote.Menu.buildFromTemplate(menuTemplate);
                menu.popup(self.remote.getCurrentWindow());
            }
        };

        // 拡大率の計算
        // level は指数で表す
        self.calcZoomRatio = function(level){
            return Math.pow(2, level);
        };

        // ズームのスタート
        self.startZoom = function(direction, offsetX, offsetY){
            if (!self.inZoomAnimation) {
                // 拡大 or 縮小
                self.zoomAnimationDirection = direction;
                self.zoomEndLevel = 
                    self.zoomLevel + (self.zoomAnimationDirection ? ZOOM_RATIO : -ZOOM_RATIO);
                self.zoomBasePoint = [offsetX, offsetY];
                self.inZoomAnimation = true;
                self.zoomAnimationID = setInterval(self.animateZoom, 16);
            }
        };

        // offsetX/offsetY を基準に，newZoomLevel を適用
        self.setZoomLevel = function(newZoomLevel, offsetX, offsetY){
            let newZoomRatio = self.calcZoomRatio(newZoomLevel);
            let oldZoomRatio = self.calcZoomRatio(self.zoomLevel);

            // ポインタの位置が拡大の前後で同じ位置を指すように変換
            let newAbsPosX = (offsetX + self.viewPoint[0]) / oldZoomRatio * newZoomRatio;
            let newAbsPosY = (offsetY + self.viewPoint[1]) / oldZoomRatio * newZoomRatio;

            // そこからマウスポインタの位置を引いて，左上の座標を決定
            self.viewPoint[0] = newAbsPosX - offsetX;
            self.viewPoint[1] = newAbsPosY - offsetY;

            // 新しいズームレベルを適用  
            self.zoomLevel = newZoomLevel;
        };

        // ズームアニメーション中は，一定時間毎に呼び出される
        self.animateZoom = function(){
            if (!self.inZoomAnimation) {
                return;
            }

            let newZoomLevel = 
                self.zoomLevel + 
                (self.zoomAnimationDirection ? ZOOM_ANIMATION_SPEED : -ZOOM_ANIMATION_SPEED);
            self.setZoomLevel(
                newZoomLevel, self.zoomBasePoint[0], self.zoomBasePoint[1]
            );
            self.draw();
            if ((self.zoomAnimationDirection && newZoomLevel > self.zoomEndLevel) ||
                (!self.zoomAnimationDirection && newZoomLevel < self.zoomEndLevel)){
                self.inZoomAnimation = false;
                clearInterval(self.zoomAnimationID);
            }
        };

        // 描画
        self.draw = function(){
            let canvas = self.refs.canvas;
            let width = canvas.width;
            let height = canvas.height;

            if (!self.tree) {
                let c = canvas.getContext("2d");
                c.fillStyle = "rgb(200,200,200)";
                c.fillRect(0, 0, width, height);
                return;
            }

            let zoom = self.calcZoomRatio(self.zoomLevel);
            let virtualWidth = BASE_SIZE[0] * zoom;
            let virtualHeight = BASE_SIZE[1] * zoom;
            let areas = self.treeMap.createTreeMap(
                self.tree, 
                virtualWidth, virtualHeight, 
                [
                    self.viewPoint[0], 
                    self.viewPoint[1], 
                    self.viewPoint[0] + width, 
                    self.viewPoint[1] + height
                ],
                TILE_MERGIN
            );

            let fillStyle = [];
            //let fillFileStyle = "hsl(" + 0 + ", 70%, 70%)";
            let strokeStyle = [];
            for (let i = 0; i < 10; i++) {
                fillStyle.push("hsl(" + ((0+i*30)%360) + ", 40%, 70%)");
                strokeStyle.push("hsl(" + ((0+i*30)%360) + ", 20%, 40%)");
            }

            let c = canvas.getContext("2d");

            c.fillStyle = "rgb(200,200,200)";
            c.fillRect(0, 0, width, height);


            let prevLevel = -1;
            for (let a of areas) {
                let rect = a.rect;
                // レベルに応じた色にする
                if (prevLevel != a.level) {
                    c.fillStyle = fillStyle[a.level];
                    prevLevel = a.level;
                }
                c.fillRect(rect[0], rect[1], rect[2] - rect[0], rect[3] - rect[1]);
            }

            prevLevel = -1;
            for (let a of areas) {
                let rect = a.rect;
                if (prevLevel != a.level) {
                    // 枠線の太さもレベルに応じる
                    //c.lineWidth = Math.max(2 - a.level/2, 0.5); 
                    c.lineWidth = 1; 
                    // 枠線の色は，基準色から明度をおとしたものに
                    c.strokeStyle = strokeStyle[a.level];
                    prevLevel = a.level;
                }
                if (!a.fileNode.children) {
                    c.lineWidth = 2; 
                    prevLevel = -1;
                }
                c.strokeRect(rect[0], rect[1], rect[2] - rect[0], rect[3] - rect[1]);
            }


            function sizeToStr(size) {
                if (size > 1024*1024) {
                    return "" + Math.ceil(size/1024/1024) + " MB";
                }
                else if (size > 1024) {
                    return "" + Math.ceil(size/1024) + " KB";
                }
                else {
                    return "" + size + " B";
                }
            }

            // 文字領域が確保できた場合は描画
            let strAreas = areas.filter(function(a){
                let rect = a.rect;
                return (rect[2] - rect[0] > 80 && rect[3] - rect[1] > 40);
            });

            // 1回太めに文字の枠線を書く
            c.font = "bold " + FONT_FIZE + "px Century Gothic";
            c.lineWidth = 4; 
            prevLevel = -1;

            for (let a of strAreas) {
                let rect = a.rect;
                if (prevLevel != a.level) {
                    c.strokeStyle = strokeStyle[a.level];
                    prevLevel = a.level;
                }
                let pos = [Math.max(0, rect[0]) + TILE_MERGIN[0]/2, rect[1] + FONT_FIZE];

                if (!a.fileNode.children) {
                    // ファイル
                    pos[0] += 10;
                    pos[1] += (rect[3] - rect[1] - FONT_FIZE*3) / 2;
                }
                c.strokeText(a.key, pos[0], pos[1]);

                if (!a.fileNode.children) {
                    c.strokeText(sizeToStr(a.fileNode.size), pos[0], pos[1] + FONT_FIZE*1.2);
                }
            }

            // 次に白を重ねて書く
            c.fillStyle = "rgb(255,255,255)";
            for (let a of strAreas) {
                let rect = a.rect;
                let pos = [Math.max(0, rect[0]) + TILE_MERGIN[0]/2, rect[1] + FONT_FIZE];
                if (!a.fileNode.children) {
                    // ファイル
                    pos[0] += 10;
                    pos[1] += (rect[3] - rect[1] - FONT_FIZE*3) / 2;
                }

                c.fillText(a.key, pos[0], pos[1]);

                if (!a.fileNode.children) {
                    c.fillText(sizeToStr(a.fileNode.size), pos[0], pos[1] + FONT_FIZE*1.2);
                }
            }
        };

        // ファイルツリー情報をセット
        self.setTree = function(tree){
            self.tree = tree;
            self.draw();
        };

        // ポイントされてる部分のパスが変わったときのハンドラ
        // 外部から設定する
        self.onPointedPathChanged = null;

        self.zoomIn = function(){
            self.startZoom(true, self.width / 2, self.height / 2);
        };
        self.zoomOut = function(){
            self.startZoom(false, self.width / 2, self.height / 2);
        };

        // エントリポイント
        // マウント時に初期化を行う
        self.on("mount", self.init);

        // サイズを適用
        self.on("update", function() {
            let canvas = self.refs.canvas;
            canvas.width = self.width;
            canvas.height = self.height;
            self.draw();
        });
    </script>
</tree_map_canvas>


<tree_map_canvas>
    <canvas ref="canvas">
    </canvas>

    <script>
        /*global treeMap*/ 

        let self = this;

        
        let private = {

            // ファイルツリー
            tree: null,

            // 表示系
            zoomLevel: 0,
            viewPoint: [0, 0],
            inDrag: false,
            prevMousePoint: [0, 0],

            // 初期化
            // タグのマウント時に呼ばれるようにする
            init: function() {
                let canvas = self.refs.canvas;
                canvas.onmousewheel = self.private.onMouseWheel;
                canvas.onmousemove = self.private.onMouseMove;
                canvas.onmousedown = self.private.onMouseDown;
                canvas.onmouseup = self.private.onMouseUp;
                canvas.onmouseleave = self.private.onMouseUp;
            },        

            // 拡大率
            calcZoomRatio: function(level) {
                return Math.pow(1.2, level);
            },

            // マウスホイール操作
            onMouseWheel: function(e) {
                let newZoomLevel = private.zoomLevel + ((e.deltaY < 0) ? 1 : -1);
                let newZoomRatio = private.calcZoomRatio(newZoomLevel);
                let oldZoomRatio = private.calcZoomRatio(private.zoomLevel);

                // ポインタの位置が拡大の前後で同じ位置を指すように変換
                let newAbsPosX = (e.offsetX + private.viewPoint[0]) / oldZoomRatio * newZoomRatio;
                let newAbsPosY = (e.offsetY + private.viewPoint[1]) / oldZoomRatio * newZoomRatio;

                // そこからマウスポインタの位置を引いて，左上の座標を決定
                private.viewPoint[0] = newAbsPosX - e.offsetX;
                private.viewPoint[1] = newAbsPosY - e.offsetY;
                
                private.zoomLevel = newZoomLevel;
                private.draw();
            },

            // マウス移動
            onMouseMove: function(e) {
                if (private.inDrag){
                    private.viewPoint[0] += private.prevMousePoint[0] - e.offsetX;
                    private.viewPoint[1] += private.prevMousePoint[1] - e.offsetY;
                    private.prevMousePoint = [e.offsetX, e.offsetY];
                    private.draw();
                }
            },
            onMouseDown: function(e) {
                if (e.buttons & 1) {
                    private.inDrag = true;
                    private.prevMousePoint = [e.offsetX, e.offsetY];
                }
            },
            onMouseUp: function(e) {
                if (!(e.buttons & 1)) { // 離したので 0 になる
                    private.inDrag = false;
                }
            },

            // 描画
            draw: function() {
                if (!self.private.tree) {
                    return;
                }

                let zoom = private.calcZoomRatio(private.zoomLevel);
                let virtualWidth = 1600 * zoom;
                let virtualHeight = 900 * zoom;
                let areas = treeMap.createTreeMap(self.private.tree, virtualWidth, virtualHeight);

                let fillStyle = [];
                let strokeStyle = [];
                for (let i = 0; i < 10; i++) {
                    fillStyle.push("hsl(" + ((0+i*30)%360) + ", 40%, 70%)");
                    strokeStyle.push("hsl(" + ((0+i*30)%360) + ", 20%, 40%)");
                }

                let canvas = self.refs.canvas;
                let width = canvas.width;
                let height = canvas.height;
                let c = canvas.getContext("2d");

                c.clearRect(0, 0, width, height);

                // ビューポートの場所に更新
                for (let a of areas) {
                    a.rect[0] -= private.viewPoint[0];
                    a.rect[1] -= private.viewPoint[1];
                    a.rect[2] -= private.viewPoint[0];
                    a.rect[3] -= private.viewPoint[1];
                }

                for (let i = 0; i < areas.length; i++) {
                    let rect = areas[i].rect;
                    
                    // レベルに応じた色にする
                    c.fillStyle = fillStyle[areas[i].level];
                    c.fillRect(rect[0], rect[1], rect[2] - rect[0], rect[3] - rect[1]);

                    // 枠線の太さもレベルに応じる
                    c.lineWidth = Math.max(2 - areas[i].level/2, 0.5); 
                    // 枠線の色は，基準色から明度をおとしたものに
                    c.strokeStyle = strokeStyle[areas[i].level];
                    c.strokeRect(rect[0], rect[1], rect[2] - rect[0], rect[3] - rect[1]);
                }

                for (let i = 0; i < areas.length; i++) {
                    let rect = areas[i].rect;

                    // 文字領域が確保できた場合は描画
                    if (rect[2] - rect[0] > 80 && rect[3] - rect[1] > 40) {

                        // 1回太めに文字の枠線を書く
                        c.font = "bold 15px Century Gothic";
                        c.lineWidth = 4; 
                        c.strokeStyle = strokeStyle[areas[i].level];
                        c.strokeText(areas[i].key, rect[0] + 5, rect[1] + 15 + 5);

                        // 次に白を重ねて書く
                        c.fillStyle = "rgb(255,255,255)";
                        c.fillText(areas[i].key, rect[0] + 5, rect[1] + 15 + 5);
                    }
                }
            }

        };

        self.private = private;

        // ファイルツリー情報をセット
        self.setTree = function(tree) {
            self.private.tree = tree;
            self.private.draw();
        };

        // エントリポイント
        // マウント時に初期化を行う
        self.on("mount", self.private.init);

        // サイズを適用
        self.on("update", function() {
            let canvas = self.refs.canvas;
            canvas.width = self.width;
            canvas.height = self.height;
            self.private.draw();
        });
    </script>
</tree_map_canvas>

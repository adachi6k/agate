
<tree_map_canvas>
    <canvas ref="canvas">
    </canvas>

    <script>
        /*global treeMap*/ 

        let self = this;

        
        let private = {

            // ファイルツリー
            tree: null,

            // 表示系
            zoomLevel: 0,   // 拡大率
            viewPoint: [0, 0],  // 仮想座標上における表示領域の左上の座標

            // ズームのアニメーション
            inZoomAnimation: false,
            zoomEndLevel: 0,
            zoomBasePoint: [0, 0],
            zoomAnimationID: 0,
            zoomAnimationDirection: false,

            // マウスのドラッグ
            inDrag: false,  // マウスでドラッグ中か
            prevMousePoint: [0, 0], // 前回のマウスポインタの位置


            // 初期化
            // タグのマウント時に呼ばれるようにする
            init: function() {
                let canvas = self.refs.canvas;
                canvas.onmousewheel = self.private.onMouseWheel;
                canvas.onmousemove = self.private.onMouseMove;
                canvas.onmousedown = self.private.onMouseDown;
                canvas.onmouseup = self.private.onMouseUp;
                canvas.onmouseleave = self.private.onMouseUp;
            },        

            // 拡大率
            calcZoomRatio: function(level) {
                return Math.pow(1.3, level);
            },

            //
            setZoomLevel: function(newZoomLevel, offsetX, offsetY) {
                let newZoomRatio = private.calcZoomRatio(newZoomLevel);
                let oldZoomRatio = private.calcZoomRatio(private.zoomLevel);

                // ポインタの位置が拡大の前後で同じ位置を指すように変換
                let newAbsPosX = (offsetX + private.viewPoint[0]) / oldZoomRatio * newZoomRatio;
                let newAbsPosY = (offsetY + private.viewPoint[1]) / oldZoomRatio * newZoomRatio;

                // そこからマウスポインタの位置を引いて，左上の座標を決定
                private.viewPoint[0] = newAbsPosX - offsetX;
                private.viewPoint[1] = newAbsPosY - offsetY;
                
                private.zoomLevel = newZoomLevel;
            },

            animateZoom: function() {
                if (!private.inZoomAnimation) {
                    return;
                }

                let newZoomLevel = private.zoomLevel + (private.zoomAnimationDirection ? 0.1 : -0.1);
                private.setZoomLevel(
                    newZoomLevel, private.zoomBasePoint[0], private.zoomBasePoint[1]
                );
                private.draw();
                if ((private.zoomAnimationDirection && newZoomLevel > private.zoomEndLevel) ||
                    (!private.zoomAnimationDirection && newZoomLevel < private.zoomEndLevel)){
                    private.inZoomAnimation = false;
                    clearInterval(private.zoomAnimationID);
                }
            },

            // マウスホイール操作
            onMouseWheel: function(e) {
                if (!private.inZoomAnimation) {
                    private.zoomAnimationDirection = (e.deltaY < 0);
                    private.zoomBasePoint = [e.offsetX, e.offsetY];
                    private.zoomEndLevel = 
                        private.zoomLevel + (private.zoomAnimationDirection ? 1.5 : -1.5);
                    private.inZoomAnimation = true;
                    private.zoomAnimationID = setInterval(private.animateZoom, 16);
                }
            },

            // マウス移動
            onMouseMove: function(e) {
                if (private.inDrag){
                    private.viewPoint[0] += private.prevMousePoint[0] - e.offsetX;
                    private.viewPoint[1] += private.prevMousePoint[1] - e.offsetY;
                    private.prevMousePoint = [e.offsetX, e.offsetY];
                    private.draw();
                }
            },
            onMouseDown: function(e) {
                if (e.buttons & 1) {
                    private.inDrag = true;
                    private.prevMousePoint = [e.offsetX, e.offsetY];
                }
            },
            onMouseUp: function(e) {
                if (!(e.buttons & 1)) { // 離したので 0 になる
                    private.inDrag = false;
                }
            },

            // 描画
            draw: function() {
                if (!self.private.tree) {
                    return;
                }

                let canvas = self.refs.canvas;
                let width = canvas.width;
                let height = canvas.height;

                let zoom = private.calcZoomRatio(private.zoomLevel);
                let virtualWidth = 1600 * zoom;
                let virtualHeight = 900 * zoom;
                let areas = treeMap.createTreeMap(
                    self.private.tree, 
                    virtualWidth, virtualHeight, 
                    [private.viewPoint[0], private.viewPoint[1], private.viewPoint[0] + width, private.viewPoint[1] + height]
                );

                let fillStyle = [];
                let strokeStyle = [];
                for (let i = 0; i < 10; i++) {
                    fillStyle.push("hsl(" + ((0+i*30)%360) + ", 40%, 70%)");
                    strokeStyle.push("hsl(" + ((0+i*30)%360) + ", 20%, 40%)");
                }

                let c = canvas.getContext("2d");

                //c.clearRect(0, 0, width, height);
                c.fillStyle = "rgb(200,200,200)";
                c.fillRect(0, 0, width, height);


                // ビューポートの場所に更新
                for (let a of areas) {
                    a.rect[0] -= private.viewPoint[0];
                    a.rect[1] -= private.viewPoint[1];
                    a.rect[2] -= private.viewPoint[0];
                    a.rect[3] -= private.viewPoint[1];
                }

                // 範囲外のオブジェクトを排除
                areas = areas.filter(function(a) {
                    if (a.rect[0] > width || a.rect[2] < 0 || 
                        a.rect[1] > height || a.rect[3] < 0) {
                        return false;
                    }
                    else {
                        return true;
                    }
                });

                /*
                areas = areas.map(function(a) {
                    if (a.rect[0] < 0) { a.rect[0] = -50; }
                    if (a.rect[1] < 0) { a.rect[1] = -50; }
                    if (a.rect[2] > width) { a.rect[2] = width+50; }
                    if (a.rect[3] > height) { a.rect[3] = height+50; }
                    return a;
                });
                */

                for (let a of areas) {
                    let rect = a.rect;
                    
                    // レベルに応じた色にする
                    c.fillStyle = fillStyle[a.level];
                    c.fillRect(rect[0], rect[1], rect[2] - rect[0], rect[3] - rect[1]);
                }

                for (let a of areas) {
                    let rect = a.rect;
                    // 枠線の太さもレベルに応じる
                    c.lineWidth = Math.max(2 - a.level/2, 0.5); 
                    // 枠線の色は，基準色から明度をおとしたものに
                    c.strokeStyle = strokeStyle[a.level];
                    c.strokeRect(rect[0], rect[1], rect[2] - rect[0], rect[3] - rect[1]);
                }

                for (let i = 0; i < areas.length; i++) {
                    let rect = areas[i].rect;

                    // 文字領域が確保できた場合は描画
                    if (rect[2] - rect[0] > 80 && rect[3] - rect[1] > 40) {

                        // 1回太めに文字の枠線を書く
                        c.font = "bold 15px Century Gothic";
                        c.lineWidth = 4; 
                        c.strokeStyle = strokeStyle[areas[i].level];
                        c.strokeText(areas[i].key, rect[0] + 5, rect[1] + 15 + 5);

                        // 次に白を重ねて書く
                        c.fillStyle = "rgb(255,255,255)";
                        c.fillText(areas[i].key, rect[0] + 5, rect[1] + 15 + 5);
                    }
                }
            }

        };

        self.private = private;

        // ファイルツリー情報をセット
        self.setTree = function(tree) {
            self.private.tree = tree;
            self.private.draw();
        };

        // エントリポイント
        // マウント時に初期化を行う
        self.on("mount", self.private.init);

        // サイズを適用
        self.on("update", function() {
            let canvas = self.refs.canvas;
            canvas.width = self.width;
            canvas.height = self.height;
            self.private.draw();
        });
    </script>
</tree_map_canvas>
